

- Escolha: **Next.js 14+ com App Router** (conforme stack_obrigatoria_frontend).
- Por que Next.js:
  - **Roteamento file-based**: facilita mapear claramente as telas mínimas (Dashboard, Criar Pedido, Status do Sistema) em rotas estáveis (`/`, `/orders/new`, `/status`), com pouca configuração.
  - **Preparado para futuro SSR/SSG**: hoje o app é mais “backoffice interno”, mas manter a opção de SSR/SSG ajuda em performance, caching e possivelmente futuras integrações (relatórios, páginas públicas).
  - **Boa integração com React 18**: suporte nativo a streaming, server components e layout hierárquico, mesmo que inicialmente usemos majoritariamente client components para TanStack Query.
  - **Ecosistema e DX**: `next lint`, integração pronta com TypeScript, conventions claras para pastas e build que se encaixam bem na estratégia de Docker (build + `next start`).
- Vantagens de Vite (reconhecidas, mas não escolhidas aqui):
  - **Dev server extremamente rápido** e configuração simples.
  - Maior liberdade de montar a arquitetura do zero (React Router, etc.).
- Por que mesmo assim **não Vite**:
  - Teríamos que **montar manualmente roteamento, code splitting, estrutura de pastas e convenções**, aumentando trabalho inicial sem ganho claro para este projeto.
  - O Dockerfile teria que encapsular um servidor adicional (por exemplo, `serve` ou `vite preview`) em vez de uma solução já consolidada (`next start`).
  - O App Router de Next encaixa muito bem com o padrão de features orientadas a “telas” que o documento front.txt define.

---

**Visão Geral da Arquitetura**

- **Camada de apresentação (UI)**:
  - Páginas do Next (App Router) em `app/`, focadas em roteamento, layout e composição de containers.
  - Componentes de UI reutilizáveis (botões, inputs, tabela, badges, cards) em `src/components/ui` (baseados em Tailwind + shadcn/ui).
  - Layout base com cabeçalho e área de conteúdo (por exemplo, menu lateral simples para navegar entre Dashboard, Criar Pedido e Status do Sistema).
- **Camada de aplicação/feature**:
  - Cada caso de uso em uma pasta de **feature** (`src/features/orders`, `src/features/system-status`).
  - Containers e hooks de “caso de uso” (ex.: carregar pedidos do dia, criar pedido, ler status de health) vivem na camada de feature, usando TanStack Query.
- **Camada de infraestrutura**:
  - Cliente HTTP (`fetch` encapsulado) + tratamento de erros alinhado aos contratos de erro do BFF.
  - Config de TanStack Query (QueryClient, provider), configuração de formatação de data/moeda, carregamento de variáveis de ambiente (`NEXT_PUBLIC_BFF_BASE_URL`).
- **Camada de contratos / domínio**:
  - Tipos TypeScript e schemas Zod representando **CreateOrderInput, OrderDTO, OrderSummaryDTO, ListOrdersResponse e ItemDTO** em um único lugar central.
  - Tanto a camada de API quanto os formulários usam esses contratos para evitar duplicação.

---

**Estrutura de Pastas Proposta (pseudo-tree)**

Raiz do projeto:

- `package.json`
- `next.config.mjs`
- `tsconfig.json`
- `tailwind.config.mjs`
- `postcss.config.mjs`
- `eslint.config.mjs` (ou `.eslintrc.*`)
- `playwright.config.ts` (se usarmos Playwright)
- `vitest.config.ts` ou `jest.config.ts` (a definir)
- `public/`
  - `favicon.ico`
  - `robots.txt`
  - eventualmente logo da aplicação
- `app/`
  - `layout.tsx`  
    - Layout raiz: aplica Tailwind, fonte, tema global, QueryClientProvider e providers de UI (ex.: toasts).
  - `page.tsx`  
    - Pode redirecionar para `/orders` ou servir um pequeno resumo (por exemplo, alias para “Dashboard de Pedidos do Dia”).
  - `orders/`
    - `page.tsx`  
      - Página **Dashboard de Pedidos do Dia** (lista + filtro de data).
  - `orders/new/`
    - `page.tsx`  
      - Página **Criar Pedido**.
  - `status/`
    - `page.tsx`  
      - Página **Status do Sistema** (health + mocks + link para docs).
  - `(providers)/` (opcional, se quisermos separar)
    - `providers.tsx`  
      - Componente que agrupa QueryClientProvider, ThemeProvider, etc., e é usado em `layout.tsx`.

Código de aplicação (dentro de `src/`):

- `src/contracts/`
  - `orders.ts`  
    - Tipos TS canônicos: `CreateOrderInput`, `OrderDTO`, `OrderSummaryDTO`, `ListOrdersResponse`, `ItemDTO`.
    - Zod schemas alinhados com os JSON Schemas do BFF.
  - `errors.ts`  
    - Tipos para as respostas de erro (Validation Error, Backend Service Error, Internal Server Error, Rate limiting).
- `src/lib/`
  - `config/`
    - `env.ts`  
      - Leitura e validação de `NEXT_PUBLIC_BFF_BASE_URL`, eventual flag de ambiente (dev/prod), etc.
  - `api/`
    - `http-client.ts`  
      - Wrapper sobre `fetch`:
        - Usa `NEXT_PUBLIC_BFF_BASE_URL`.
        - Encapsula cabeçalhos padrão, parse de JSON, e mapeamento de erros no formato descrito em `[ERROS_E_FORMATO_DE_ERRO]`.
      - Responsável por garantir que respostas de erro tenham shape consistente para a UI.
    - `orders.ts`  
      - Funções puras de API:
        - `postCreateOrder(input: CreateOrderInput) -> Promise<OrderDTO>`
        - `getOrdersByDate(date: string) -> Promise<ListOrdersResponse>`
      - Usa `http-client` e tipos de `src/contracts/orders.ts`.
    - `health.ts`
      - Funções de API:
        - `getHealthReady()`
        - eventual função para checar mocks (ASSUMED: se vier um endpoint no futuro).
  - `query/`
    - `query-client.ts`
      - Criação e configuração do `QueryClient` do TanStack Query.
      - Integração opcional com React Query Devtools em ambiente de desenvolvimento.
  - `formatting/`
    - `currency.ts`  
      - Funções helpers para formatar valores em BRL conforme `currency_padrao` e `Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" })`.
    - `date.ts`  
      - Funções helpers para formatar datas (`dd/MM/yyyy HH:mm`) assumindo entrada em ISO/UTC e conversão para timezone local do navegador.
- `src/features/`
  - `orders/`
    - `components/`
      - Componentes específicos de UI da feature, por exemplo:
        - Tabela de pedidos do dia.
        - Linha de item do pedido.
        - Resumo de totals no formulário.
    - `hooks/`
      - `useListOrders.ts`  
        - Hook usando TanStack Query (`useQuery`) para GET `/api/orders?date=YYYY-MM-DD`.
      - `useCreateOrder.ts`  
        - Hook usando TanStack Query (`useMutation`) para POST `/api/orders`.
    - `schemas/`
      - `create-order-schema.ts`  
        - Schema Zod para CreateOrderInput, incluindo mensagens em PT-BR e regras extra de UX (por exemplo, números > 0).
    - `containers/`
      - `OrdersDashboardContainer.tsx`  
        - Componente que usa `useListOrders` e monta a tabela/filtros/estado de loading/erro/vazio.
      - `CreateOrderContainer.tsx`  
        - Componente que coordena o formulário de criação de pedido.
    - `types.ts` (se precisarmos de tipos adicionais internos de UI, além dos contratos canônicos).
  - `system-status/`
    - `hooks/`
      - `useSystemHealth.ts`  
        - Consulta periódica a `/health/ready` com TanStack Query (intervalos, retry, etc.).
    - `components/`
      - Cards de status, badge de mocks ON/OFF, link para `/docs`.
    - `containers/`
      - `SystemStatusContainer.tsx`
- `src/components/`
  - `ui/`
    - Componentes gerados/derivados de shadcn/ui (button, input, table, badge, card, toast, etc.).
    - Cada componente deverá ter sua **proveniência documentada** em metadados (ver abaixo).
  - `layout/`
    - `AppShell.tsx`  
      - Organiza header, sidebar e conteúdo principal.
  - `feedback/`
    - Componentes de toast, alert, banners de erro global.
  - `forms/`
    - Abstrações genéricas integrando `react-hook-form` + shadcn inputs (por exemplo, `FormField`, `FormErrorMessage`).
- `src/styles/`
  - `globals.css`  
    - Importa Tailwind base, components, utilities, estilos globais mínimos.
  - `theme.css` (opcional)  
    - Tokens de cor, se quisermos separar do Tailwind.
- `src/provenance/`
  - `ui-provenance.json` (ou similar)
    - Objeto de metadados com `source_url`, `data_de_acesso`, `breve_descricao_do_uso` para cada conjunto de componentes adaptados de templates externos, respeitando `[REGRAS_DE_PROVENANCE_PARA_LLM_DEV]`.

---

**Integração de TanStack Query**

- **Configuração global**:
  - `src/lib/query/query-client.ts` define o `QueryClient` com:
    - Estratégia padrão de retry (leve), cache time e stale time adequados aos endpoints (`/api/orders` pode ser cacheado brevemente; `/health/ready` precisa ser mais fresco).
    - Interceptor de erros (via `onError` padrão) que converte erros em mensagens de UI alinhadas com os formatos do BFF.
  - Um componente `AppProviders` (em `app/(providers)/providers.tsx` ou `src/providers/app-providers.tsx`) insere `QueryClientProvider` e, em desenvolvimento, `ReactQueryDevtools`.
- **Organização de queries/mutations**:
  - **Orders**:
    - `useListOrders` (em `src/features/orders/hooks/useListOrders.ts`) usa `getOrdersByDate` e expõe estados `data`, `isLoading`, `isError`, `refetch` para a Dashboard.
    - `useCreateOrder` (em `src/features/orders/hooks/useCreateOrder.ts`) usa `postCreateOrder` e expõe `mutate`, `isPending`, `error`, com callbacks de sucesso para mostrar toasts e invalidar cache da lista do dia.
  - **System Status**:
    - `useSystemHealth` (em `src/features/system-status/hooks/useSystemHealth.ts`) usa `getHealthReady` e configura polling leve (ex.: a cada 30s) via `refetchInterval`.

---

**Integração de Zod + react-hook-form**

- **Local dos schemas**:
  - `src/features/orders/schemas/create-order-schema.ts` define o schema Zod de `CreateOrderInput`, refletindo exatamente o JSON Schema (campos obrigatórios, tipos, mínimo de itens, etc.), mas com mensagens de erro em PT-BR apropriadas para a UI.
  - Esse schema é reutilizado:
    - No formulário (`react-hook-form` + `zodResolver`).
    - Opcionalmente, na camada de API (validate client-side antes de enviar).
- **Estrutura dos formulários**:
  - Formular de Criar Pedido:
    - Arquivo principal em `src/features/orders/containers/CreateOrderContainer.tsx`, que:
      - Cria o `useForm` com `zodResolver(createOrderSchema)`.
      - Usa componentes de formulário compartilhados (`src/components/forms`) + componentes shadcn/ui (`Input`, `Button`, `Table`, etc.).
    - Erros de backend:
      - Em caso de 400 com `details` (ZodError serializado), o hook `useCreateOrder` mapeia `details[].path` para campos do formulário, permitindo exibir erros alinhados com o backend (ex.: “Invalid uuid” em `customerId`).
- **Validações adicionais de UX**:
  - Por exemplo, garantir que:
    - `quantity` seja inteiro positivo.
    - `unitPrice` seja > 0.
    - `items` tenha pelo menos 1 item antes de permitir submit.
  - Essas validações são modeladas no próprio schema Zod, coerentes com o contrato canônico.

---

**Integração de Tailwind + shadcn/ui**

- **Configuração Tailwind**:
  - `tailwind.config.mjs`:
    - `content` aponta para arquivos em `app/**/*.{ts,tsx}`, `src/**/*.{ts,tsx}`, etc.
    - Extensões de tema mínimas para cores de status (“Pago”, “Aguardando Pagamento”, “Cancelado”), alinhadas com requisitos de acessibilidade.
  - `postcss.config.mjs` com `tailwindcss` e `autoprefixer`.
  - `src/styles/globals.css` importa diretivas do Tailwind e define estilos globais básicos.
- **Pastas de componentes shadcn/ui**:
  - `src/components/ui/` conterá:
    - Botões, inputs, select, tabela, card, badge, toast, etc., derivados de shadcn/ui.
    - Cada componente ou grupo de componentes referencia, em metadados, sua origem (proveniência) conforme `[PROVENANCE_E_TEMPLATES]` e `[REGRAS_DE_PROVENANCE_PARA_LLM_DEV]`.
- **Regras de provenance (planejamento)**:
  - Para cada conjunto de componentes importados/adaptados de:
    - `https://ui.shadcn.com/`
    - `https://tailwindcomponents.com/`
    - `https://www.radix-ui.com/primitives`
  - Registraremos no `src/provenance/ui-provenance.json`:
    - `source_url`
    - `data_de_acesso`
    - `breve_descricao_do_uso`
  - Comentários estruturais em arquivos de componente podem referenciar um ID desse JSON (sem copiar código licenciado de forma restrita).

---

**Camada de API e Tratamento de Erros**

- **Http client** (`src/lib/api/http-client.ts`):
  - Responsável por:
    - Montar a URL base usando `NEXT_PUBLIC_BFF_BASE_URL` (por padrão, `http://localhost:3000`).
    - Adicionar cabeçalhos padrão (`Content-Type: application/json`, `Accept: application/json`, `X-Correlation-Id` se for necessário no futuro).
    - Fazer parsing de respostas e mapear:
      - 400 (Validation Error) → objeto com `fieldErrors` baseado em `details`.
      - 429 (rate limiting) → mensagem amigável única.
      - 500 (Internal Server Error) → mensagem genérica.
      - Erros de rede/timeouts → tratados como “erro de backend” similar ao `Backend Service Error`.
- **Integração com TanStack Query**:
  - As funções de API (`postCreateOrder`, `getOrdersByDate`, `getHealthReady`) retornam sempre tipos fortes (`OrderDTO`, `ListOrdersResponse`, etc.).
  - Os hooks de query/mutation convertem eventuais erros HTTP em objetos prontos para a UI (por exemplo, `validationError`, `backendErrorMessage`), simplificando os componentes.

---

**Dependências Recomendadas (alto nível)**

_Bibliotecas principais_:

- **Framework / React / Next**:
  - `next` (14+)
  - `react`
  - `react-dom`
- **Estado de dados / HTTP**:
  - `@tanstack/react-query`
  - `@tanstack/react-query-devtools` (dev only)
- **Formulários e validação**:
  - `react-hook-form`
  - `zod`
  - `@hookform/resolvers` (para `zodResolver`)
- **Estilo / UI**:
  - `tailwindcss`
  - `postcss`
  - `autoprefixer`
  - Dependências típicas de shadcn/ui:
    - `class-variance-authority`
    - `clsx`
    - `tailwind-merge`
    - `lucide-react` (ícones, se desejado)
    - `@radix-ui/react-*` (primitives específicos conforme componentes adotados)
- **Utilitários**:
  - Opcional: `date-fns` com locale `pt-BR` para formatações mais sofisticadas de datas (ASSUMED: útil, mas não estritamente necessário; podemos ficar apenas com `Intl.DateTimeFormat` se preferir reduzir dependências).

_DevDependencies_:

- **TypeScript e tipagem**:
  - `typescript`
  - `@types/react`
  - `@types/react-dom`
- **Lint / formatação**:
  - `eslint`
  - `eslint-config-next`
  - `@typescript-eslint/eslint-plugin`
  - `@typescript-eslint/parser`
  - `prettier` (opcional, mas recomendado)
- **Testes (unitários e de integração de componentes)**:
  - Opção A (mais alinhada com Next tradicional):
    - `jest`
    - `ts-jest`
  - Opção B (mais moderna, rápida; ASSUMED: preferível):  
    - `vitest`
  - Em ambos os casos:
    - `@testing-library/react`
    - `@testing-library/jest-dom`
    - `@testing-library/user-event`
- **Testes end-to-end (recomendado)**:
  - `@playwright/test`
- **Ferramentas auxiliares**:
  - `cross-env` (para scripts que precisem de variáveis multiplataforma, se necessário).

---

**Scripts npm Propostos (alto nível, sem comandos exatos)**

Pensando na estratégia de Docker (`node:20-alpine`, porta 3001, `npm run build` + `npm run start`):

- `dev`
  - Executa o servidor de desenvolvimento do Next na porta **3001**, usando `NEXT_PUBLIC_BFF_BASE_URL=http://localhost:3000`.
- `build`
  - Gera o build de produção do Next (otimizado), pronto para ser usado na imagem final do Docker.
- `start`
  - Inicia o servidor Next em modo produção na porta **3001**, apontando para o BFF em `http://localhost:3000`.
- `lint`
  - Roda o ESLint sobre `app/` e `src/`, validando padrões de código e acessibilidade básica.
- `typecheck`
  - Roda o TypeScript em modo `--noEmit` para garantir consistência de tipos (importante para manter contratos com o BFF corretos).
- `test`
  - Script genérico que pode delegar para `test:unit`.
- `test:unit`
  - Executa os testes unitários e de componentes (Vitest ou Jest + Testing Library).
- `test:e2e`
  - Executa testes end-to-end (Playwright) focados em:
    - Criar pedido com sucesso usando mocks do BFF.
    - Renderizar a lista de pedidos do dia.
    - Exibir mensagens de erro em 400/500.
- `test:smoke`
  - Executa scripts mínimos (por exemplo, wrappers em Node que chamam os comandos `curl` de health, criação e listagem de pedidos definidos em `[ACCEPTANCE_TESTS_CURL]`), para garantir que:
    - `/health/ready` responde 200 quando o BFF está “READY”.
    - `POST /api/orders` funciona com um payload mínimo.
    - `GET /api/orders?date=YYYY-MM-DD` retorna o envelope esperado.
- `format` (opcional)
  - Aplica `prettier` sobre o código.

Esses scripts são compatíveis com um Dockerfile multistage que:

1. Usa `npm ci` + `npm run build` na fase de build.
2. Usa `npm run start` na fase final de runtime.

---

**Pontos MISSING_DATA e ASSUMED que impactam o design**

- **MISSING_DATA: frontend_design_previo**
  - Não há maquetes/wireframes; o layout base (AppShell, posição de filtros, etc.) será **ASSUMED** minimalista e funcional, priorizando:
    - Claridade de tabela na Dashboard.
    - Formulário de criação com foco em fluxo de tabulação e acessibilidade.
    - Tela de Status do Sistema simples, tipo cards + badges.
- **MISSING_DATA: auth_frontend_publico**
  - Hoje **ASSUMED**: nenhuma autenticação (frontend totalmente público, usado em ambiente interno).
  - Implicação de design:
    - Estrutura atual não contempla contexto de autenticação; mas a organização por features permite introduzir mais tarde um provider de auth e proteções de rota sem grandes refactors.
- **ASSUMED: currency_padrao=BRL e timezone local**
  - Já refletido na criação de helpers em `src/lib/formatting/currency.ts` e `date.ts`.
  - Essa decisão é central para o design dos componentes de tabela e do resumo do pedido.
- **ASSUMED: estratégia de paginação**
  - Sem paginação inicial; a **Dashboard de Pedidos do Dia** assume lista do dia inteira.
  - A estrutura por features (hooks, containers, etc.) permite introduzir paginação ou infinite queries do TanStack Query no futuro, sem quebrar o desenho atual.
- **ASSUMED: indicador de USE_MOCKS**
  - O documento indica que a UI deve ter uma seção de debug em dev para mostrar se `USE_MOCKS` está ativo, “via endpoint dedicado ou flag manual”.
  - Como o endpoint ainda não está especificado:
    - **ASSUMED**: iniciaremos com uma flag manual (por exemplo, uma variável de ambiente ou configuração manual em dev) representada na tela de Status do Sistema.
    - Futuramente, podemos adicionar uma função de API específica para consultar esse status e integrá-la a `useSystemHealth` ou a outro hook.

