AEGIS — BACKEND CORE
DESCRIÇÃO TÉCNICA DEFINITIVA (FONTE ÚNICA DE VERDADE)

====================================================
1. OBJETIVO DO BACKEND
====================================================

Implementar o Backend Core do sistema Aegis Financial Architecture, responsável por:

- Dominar 100% das regras de negócio
- Garantir consistência do domínio
- Controlar transições de estado
- Persistir dados primários e derivados
- Expor APIs estáveis para consumidores internos (BFF e Batch)
- Operar corretamente em ambiente local containerizado (Docker)

Este backend deve ser desenvolvido assumindo que:
- Ele NÃO conhece frontend
- Ele NÃO conhece BFF
- Ele NÃO conhece Batch internamente
- Ele apenas expõe contratos claros e seguros

====================================================
2. ESCOPO EXATO DESTA ENTREGA
====================================================

INCLUI:
- Domínio (Order, OrderItem, DailyReport)
- Regras de negócio e invariantes
- Casos de uso explícitos (application layer)
- Persistência com PostgreSQL
- Migrations versionadas com Flyway
- APIs públicas (para BFF)
- APIs internas protegidas (para Batch)
- Observabilidade mínima
- Execução local via Docker

NÃO INCLUI:
- Implementação do Batch
- Implementação do BFF
- Implementação do Frontend
- Cache distribuído
- Mensageria (Kafka, RabbitMQ, etc)
- Deploy em cloud

====================================================
3. STACK TÉCNICA (OBRIGATÓRIA)
====================================================

- Java 21
- Spring Boot 3.x
- Maven
- Spring Web
- Spring Data JPA (Hibernate)
- PostgreSQL
- Flyway (schema versioning)
- Bean Validation (Jakarta)
- Jackson
- Spring Actuator
- JUnit 5 + Mockito
- Testcontainers (integração)
- Docker + Docker Compose

Configurações proibidas:
- spring.jpa.hibernate.ddl-auto != none
- geração automática de schema
- lógica de negócio em controller

====================================================
4. PRINCÍPIOS ARQUITETURAIS INEGOCIÁVEIS
====================================================

1. O Backend é o ÚNICO dono do domínio
2. Nenhuma regra de negócio vive fora do domínio
3. Batch NÃO altera estado diretamente no banco
4. Batch só escreve dados DERIVADOS
5. Backend valida tudo, sempre
6. Toda escrita relevante gera audit log
7. Execução local deve simular produção (Docker)

====================================================
5. MODELO DE DOMÍNIO
====================================================

-------------------------
Order (Pedido)
-------------------------

Campos:
- id: UUID (PK)
- customer_name: varchar NOT NULL
- table_number: integer NULL
- status: ENUM {CREATED, PAID, CANCELED}
- total_amount: numeric NOT NULL
- created_at: timestamp
- updated_at: timestamp

Regras de domínio:
- Pedido nasce sempre em CREATED
- total_amount é SEMPRE calculado no backend
- Transições válidas:
  - CREATED → PAID
  - CREATED → CANCELED
- PAID é estado final (não pode cancelar)
- Cancelamento após pagamento é proibido

-------------------------
OrderItem
-------------------------

Campos:
- id: UUID (PK)
- order_id: FK orders(id)
- name: varchar NOT NULL
- quantity: integer > 0
- unit_price: numeric >= 0

Regras:
- Pedido sem itens é inválido
- Quantidade nunca pode ser zero ou negativa

-------------------------
DailyReport (Read Model)
-------------------------

Campos:
- id: UUID (PK)
- report_date: date UNIQUE
- total_orders: integer
- total_revenue: numeric
- top_items: jsonb
- status: ENUM {OPEN, CLOSED}
- created_at
- updated_at

Observações:
- NÃO representa domínio de negócio
- É modelo derivado
- Criado exclusivamente via endpoint interno
- status sempre CLOSED ao persistir

====================================================
6. ESTRUTURA DE PACOTES (OBRIGATÓRIA)
====================================================

com.aegis.backend
 ├── domain
 │   ├── order
 │   │   ├── Order.java
 │   │   ├── OrderItem.java
 │   │   └── OrderStatus.java
 │   └── report
 │       ├── DailyReport.java
 │       └── ReportStatus.java
 ├── application
 │   ├── order
 │   │   ├── CreateOrderUseCase
 │   │   ├── PayOrderUseCase
 │   │   ├── CancelOrderUseCase
 │   │   └── ListOrdersUseCase
 │   └── report
 │       ├── GetDailyReportUseCase
 │       └── RegisterDailyReportUseCase
 ├── infrastructure
 │   ├── persistence
 │   │   ├── jpa
 │   │   └── repositories
 │   ├── web
 │   │   ├── public
 │   │   └── internal
 │   └── config
 └── shared
     ├── exceptions
     ├── validation
     ├── audit
     └── dto

====================================================
7. MIGRATIONS (FLYWAY)
====================================================

V1__create_orders.sql
- orders
- order_items
- índices em created_at, status, item name

V2__create_daily_reports.sql
- daily_reports
- UNIQUE(report_date)

V3__create_audit_logs.sql
- audit_logs (payload JSONB)

Flyway:
- Executa em dev/test
- Falha o startup se migration quebrar
- Hibernate NÃO cria nada

====================================================
8. APIs PÚBLICAS (BFF / FRONT)
====================================================

POST /orders
- Cria pedido
- Backend calcula total_amount

POST /orders/{id}/pay
- Valida existência
- Valida estado atual
- Transiciona para PAID

POST /orders/{id}/cancel
- Permitido apenas se CREATED

GET /orders?date=YYYY-MM-DD
- Lista pedidos do dia

GET /reports/{date}
- Retorna relatório diário persistido

====================================================
9. APIs INTERNAS (BATCH → BACKEND)
====================================================

POST /internal/reports/daily

Proteção:
- Header X-SERVICE-TOKEN obrigatório
- Secret configurado via env no Docker

Comportamento:
- Valida payload
- Checa idempotência (report_date)
- Se existir: retorna 200 ou 409
- Persiste daily_report
- Gera audit_log
- Status = CLOSED

====================================================
10. SEGURANÇA
====================================================

- Endpoints internos isolados
- Token via variável de ambiente
- Logs de todas chamadas internas
- Sem exposição pública de endpoints /internal

====================================================
11. OBSERVABILIDADE
====================================================

- /actuator/health
- /actuator/metrics
- Logs estruturados (JSON)
- correlationId por request

====================================================
12. EXECUÇÃO LOCAL (DOCKER)
====================================================

- Backend e PostgreSQL via Docker Compose
- Configuração por profiles (dev/test)
- Banco efêmero para dev
- Testcontainers para testes de integração
- Ambiente local deve simular produção em comportamento

====================================================
13. CRITÉRIO DE ACEITAÇÃO FINAL
====================================================

O backend está concluído quando:
- Regras de domínio estão testadas
- Migrations executam sem erro
- APIs públicas funcionam
- Endpoint interno protegido
- Health endpoint retorna 200
- Relatório diário pode ser registrado
- Aplicação roda 100% via Docker local

====================================================
FIM DO DOCUMENTO
====================================================
