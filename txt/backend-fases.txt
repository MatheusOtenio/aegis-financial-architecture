visÃ£o geral do projeto aegis-financial-architecture 
## VisÃ£o geral da arquitetura

Front (React / TypeScript)       
        â†“
BFF (Node / Express)             
        â†“
Backend Core (Java / Spring) NESSE DOCUMENTO DEVE SER FEITO SOMENTE ESSA PARTE (backend)
        â†•
PostgreSQL + Flyway            
        â†‘
Batch Job (Java / Spring) 

# ROADMAP TÃ‰CNICO â€” AEGIS BACKEND CORE

**Java 21 Â· Spring Boot 3 Â· PostgreSQL Â· Flyway Â· Arquitetura Limpa**

OBS: O backend deve ser construido para justificar a existencia de um BFF:
- Agrega dados de mÃºltiplos endpoints
- Transforma payloads
- ExpÃµe DTOs orientados Ã  UI
- Reduz nÃºmero de chamadas do frontend
- Pode aplicar cache de leitura e rate limit

---

## ğŸ”¹ FASE 0 â€” DecisÃµes Fundamentais (Antes de qualquer cÃ³digo)

Objetivo: **eliminar decisÃµes implÃ­citas e evitar retrabalho**.

* Nome do projeto: `aegis-backend`
* GroupId Maven: `com.aegis`
* ArtifactId: `backend`
* Java: **21**
* Build: **Maven**
* Profile ativo padrÃ£o: `dev`
* Banco oficial: **PostgreSQL**
* ORM: **JPA/Hibernate apenas para leitura/escrita, nunca para schema**
* Fonte de verdade do schema: **Flyway**
* Arquitetura: **Domain â†’ Application â†’ Infrastructure**
* ComunicaÃ§Ã£o externa: **REST**
* ComunicaÃ§Ã£o interna (batch): **REST protegido por token**
* Ambiente local: **Docker obrigatÃ³rio**

Nada Ã© implementado fora dessas decisÃµes.

---

## ğŸ”¹ FASE 1 â€” Scaffold Estrutural do Projeto

Objetivo: **criar a espinha dorsal correta do backend**.

### Estrutura de pastas base:

```text
/aegis-backend
 â”œâ”€â”€ docker
 â”‚   â””â”€â”€ docker-compose.yml
 â”œâ”€â”€ src/main/java/com/aegis/backend
 â”‚   â”œâ”€â”€ domain
 â”‚   â”œâ”€â”€ application
 â”‚   â”œâ”€â”€ infrastructure
 â”‚   â””â”€â”€ shared
 â”œâ”€â”€ src/main/resources
 â”‚   â”œâ”€â”€ application.yml
 â”‚   â”œâ”€â”€ application-dev.yml
 â”‚   â”œâ”€â”€ application-test.yml
 â”‚   â””â”€â”€ db/migration
 â””â”€â”€ pom.xml
```

### DependÃªncias obrigatÃ³rias (sem exceÃ§Ã£o):

* Spring Web
* Spring Data JPA
* PostgreSQL Driver
* Flyway
* Bean Validation (Jakarta)
* Lombok
* Spring Actuator
* Jackson
* JUnit 5
* Mockito
* Testcontainers

### ConfiguraÃ§Ãµes proibidas jÃ¡ nesta fase:

* `spring.jpa.hibernate.ddl-auto`
* Qualquer criaÃ§Ã£o automÃ¡tica de tabela
* Controllers fora de `infrastructure.web`

---

## ğŸ”¹ FASE 2 â€” Ambiente Local Profissional (Docker First)

Objetivo: **simular produÃ§Ã£o desde o primeiro dia**.

### Docker Compose:

* ServiÃ§o `postgres`

  * Database: `aegis`
  * User: `aegis`
  * Password via env
  * Porta exposta apenas para dev
* ServiÃ§o `backend`

  * Build da aplicaÃ§Ã£o
  * Profile `dev`
  * ConexÃ£o com Postgres via network Docker

### Regras desta fase:

* Backend **nÃ£o sobe sem banco**
* Flyway **executa no startup**
* Se migration falhar, **aplicaÃ§Ã£o nÃ£o inicia**

Nada de rodar app fora do Docker a partir daqui.

---

## ğŸ”¹ FASE 3 â€” Modelagem do DomÃ­nio (Sem PersistÃªncia Ainda)

Objetivo: **definir o coraÃ§Ã£o do sistema**.

### Pacotes criados:

```text
domain
 â”œâ”€â”€ order
 â”‚   â”œâ”€â”€ Order
 â”‚   â”œâ”€â”€ OrderItem
 â”‚   â””â”€â”€ OrderStatus
 â””â”€â”€ report
     â”œâ”€â”€ DailyReport
     â””â”€â”€ ReportStatus
```

### Regras obrigatÃ³rias implementadas no domÃ­nio:

#### Order

* Estado inicial: `CREATED`
* Estados finais: `PAID`
* TransiÃ§Ãµes vÃ¡lidas:

  * CREATED â†’ PAID
  * CREATED â†’ CANCELED
* Proibido:

  * Cancelar pedido `PAID`
  * Alterar total manualmente
* `total_amount` calculado exclusivamente pelo backend

#### OrderItem

* `quantity > 0`
* `unit_price >= 0`
* Pedido sem itens Ã© invÃ¡lido

#### DailyReport

* NÃ£o contÃ©m regras de negÃ³cio
* Status sempre `CLOSED`
* Ã‰ modelo derivado

Nenhuma anotaÃ§Ã£o de banco aqui alÃ©m do essencial de entidade.

---

## ğŸ”¹ FASE 4 â€” Banco de Dados como Fonte de Verdade (Flyway)

Objetivo: **garantir rastreabilidade e versionamento real**.

### Migrations obrigatÃ³rias:

1. `V1__create_orders.sql`

   * Tabela `orders`
   * Tabela `order_items`
   * Ãndices:

     * `orders.created_at`
     * `orders.status`
     * `order_items.name`

2. `V2__create_daily_reports.sql`

   * Tabela `daily_reports`
   * UNIQUE em `report_date`

3. `V3__create_audit_logs.sql`

   * Tabela `audit_logs`
   * Payload em JSONB

### Regras:

* Flyway executa sempre
* Hibernate **apenas valida**
* Qualquer alteraÃ§Ã£o de schema exige nova migration

---

## ğŸ”¹ FASE 5 â€” PersistÃªncia (Infrastructure Layer)

Objetivo: **ligar domÃ­nio ao banco sem vazar regras**.

### Pacotes criados:

```text
infrastructure/persistence
 â”œâ”€â”€ jpa
 â””â”€â”€ repositories
```

### Regras:

* RepositÃ³rios seguem contrato do domÃ­nio
* Nenhuma lÃ³gica de negÃ³cio em repository
* Queries complexas ficam explÃ­citas
* Uso de UUID como chave primÃ¡ria

---

## ğŸ”¹ FASE 6 â€” Casos de Uso (Application Layer)

Objetivo: **expressar o sistema em aÃ§Ãµes claras**.

### Use Cases obrigatÃ³rios:

```text
application/order
 â”œâ”€â”€ CreateOrderUseCase
 â”œâ”€â”€ PayOrderUseCase
 â”œâ”€â”€ CancelOrderUseCase
 â””â”€â”€ ListOrdersUseCase

application/report
 â”œâ”€â”€ GetDailyReportUseCase
 â””â”€â”€ RegisterDailyReportUseCase
```

### Regras:

* Cada UseCase = 1 responsabilidade
* Controllers apenas delegam
* Toda validaÃ§Ã£o de fluxo acontece aqui
* DomÃ­nio decide se algo Ã© vÃ¡lido ou nÃ£o

---

## ğŸ”¹ FASE 7 â€” APIs PÃºblicas (BFF / Front)

Objetivo: **expor contratos estÃ¡veis e seguros**.

### Endpoints pÃºblicos:

* `POST /orders`
* `POST /orders/{id}/pay`
* `POST /orders/{id}/cancel`
* `GET /orders?date=YYYY-MM-DD`
* `GET /reports/{date}`

### OrganizaÃ§Ã£o:

```text
infrastructure/web/public
```

### Regras:

* DTOs explÃ­citos
* Nunca expor entidade diretamente
* Backend calcula tudo
* Erros de domÃ­nio retornam HTTP correto

---

## ğŸ”¹ FASE 8 â€” APIs Internas (Batch)

Objetivo: **permitir escrita derivada com seguranÃ§a**.

### Endpoint interno:

* `POST /internal/reports/daily`

### SeguranÃ§a:

* Header obrigatÃ³rio: `X-SERVICE-TOKEN`
* Token vindo de variÃ¡vel de ambiente
* Endpoint isolado do pÃºblico

### Comportamento obrigatÃ³rio:

* ValidaÃ§Ã£o de payload
* IdempotÃªncia por `report_date`
* GeraÃ§Ã£o de audit log
* Status do report = `CLOSED`

---

## ğŸ”¹ FASE 9 â€” Auditoria e ExceÃ§Ãµes

Objetivo: **rastreabilidade total**.

### Pacotes:

```text
shared
 â”œâ”€â”€ exceptions
 â”œâ”€â”€ audit
 â””â”€â”€ validation
```

### Regras:

* Toda escrita relevante gera audit log
* ExceÃ§Ãµes de domÃ­nio sÃ£o explÃ­citas
* Nada de `RuntimeException` genÃ©rica

---

## ğŸ”¹ FASE 10 â€” Observabilidade e SaÃºde

Objetivo: **backend profissional, operÃ¡vel**.

* `/actuator/health`
* `/actuator/metrics`
* Logs estruturados em JSON
* CorrelationId por request

---

## ğŸ”¹ FASE 11 â€” Testes Reais

Objetivo: **confianÃ§a no domÃ­nio**.

* UnitÃ¡rios para regras de domÃ­nio
* UnitÃ¡rios para UseCases
* IntegraÃ§Ã£o com Testcontainers
* Testes falham se migration quebrar

---

## ğŸ”¹ FASE 12 â€” CritÃ©rio de ConclusÃ£o

O projeto estÃ¡ **finalizado** quando:

* Regras de domÃ­nio estÃ£o testadas
* Banco sobe via Docker
* Flyway executa limpo
* APIs pÃºblicas funcionam
* Endpoint interno protegido
* Audit logs gerados
* Health retorna 200
* Sistema roda 100% local via Docker

---

